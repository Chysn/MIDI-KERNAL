;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                   MIDI KERNAL
;                    MIDI Routines for VIC-20 User Port Projects
;                             (c)2021, Jason Justian
;                  
; Release 1 - September 2, 2021
; Release 2 - September 17, 2021
; Assembled with XA
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2021, Jason Justian
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI OUTPUT DOCUMENTATION
;
; Channel messages have their own MIDI KERNAL routines
; Example
;     jsr SETOUT                ; SETOUT and SETCH don't need to be done for
;     lda #CHANNEL              ;   each command invocation, only when they need
;     jsr SETCH                 ;   to be changed
;     ldx #DATA1                ; Range of DATA1 is 0 - 127
;     ldy #DATA2                ; Range of DATA2 is 0 - 127
;     jsr ROUTINE               ; See the routine table below
;
; System messages are generated byte-by-byte with the MIDIOUT routine
; Example
;     lda #ST_CLOCK
;     jsr MIDIOUT
;
;    ROUTINE    ;     DESCRIPTION       ;     DATA1 (X)     ;     DATA2  (Y)     
;---------------;-----------------------;-------------------;-------------------
; NOTEON        ; Note On               ; Note Number       ; Velocity
; NOTEOFF       ; Note Off              ; Note Number       ; Velocity*
; POLYPRES      ; Polyphonic Pressure   ; Note Number       ; Pressure Amount
; CONTROLC      ; Control Change        ; Controller Number ; Control Amount
; PROGRAMC      ; Program Change        ; Program Number    ; (unused)
; CHPRES        ; Channel Pressure      ; Pressure Amount   ; (unused)
; PITCHB        ; Pitch Bend            ; Amount - LSB      ; Amount - MSB
;
; * Usually optional, check instrument's implementation chart
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                            MIDI INPUT DOCUMENTATION
;
; Example
;     jsr SETIN                 ; In setup routine where MIDI In is expected
;
;     ; Main loop checks for complete MIDI message and acts on it
;     jsr GETMSG                ; Has a complete MIDI message been received?
;     bcc main_loop             ; If not, do whatever else your program does
;     cmp #ST_NOTEON            ; Dispatch each implemented MIDI command to
;     beq handle_note_on        ;   the appropriate code.
;     cmp #ST_NOTEOFF           ;   * X holds DATA1 and Y holds DATA2
;     beq handle_note_off       ;   * Use jsr GETCH to get the message channel
;     ; etc....                 ;   * See "Status Message Constants" below
;
;     ; Interrupt Service Routine ($0318/$0319 NMI vector)
; isr pha                       ; Custom NMI handlers need to store registers
;     txa                       ;   for return.
;     pha                       ;   ,,
;     tya                       ;   ,,
;     pha                       ;   ,,
;     jsr CHKMIDI               ; Is this a MIDI-based interrupt?
;     bne mi                    ;   If so, handle MIDI input
;     jmp $feb2                 ;   If not, RESTORE was (probably) pressed
; mi  jsr MAKEMSG               ; Get waiting MIDI byte and add to message
;     pla                       ; Return from MIDI interrupt (or jmp $ff56)
;     tay                       ; ,,
;     pla                       ; ,,
;     tax                       ; ,,
;     pla                       ; ,,
;     rti                       ; ,,
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LABEL DEFINITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VIA Registers (VIA#1, Port B)
DDR         = $9112             ; Data Direction Register
UPORT       = $9110             ; User Port
PCR         = $911c             ; Peripheral Control Register
IFR         = $911d             ; Interrupt flag register
IER         = $911e             ; Interrupt enable register

; Memory Locations
MIDIST      = $9e               ; Bits 0-3 = Channel, bits 4-7 = Last Status
DATA1       = $9c               ; MIDI data bytes
DATA2       = $9b               ; ,,
DATACOUNT   = $9f               ; Data byte countdown, 0 = message waiting

; Status Message Constants
ST_NOTEON   = $90               ; Note On
ST_NOTEOFF  = $80               ; Note Off
ST_POLYPR   = $a0               ; Poly Pressure
ST_CONTROLC = $b0               ; Control Change
ST_PROGRAMC = $c0               ; Program Change
ST_CHPR     = $d0               ; Channel Pressure
ST_PITCHB   = $e0               ; Pitch Bend

; System Message Constants ($f0-$ff)
ST_SYSEX    = $f0               ; Start System Exclusive
ST_MTC      = $f1               ; MIDI Time Code            (1 data)
ST_SONGPOS  = $f2               ; Song Position Pointer     (2 data)
ST_SONGSEL  = $f3               ; Song Select               (1 data)
ST_TUNEREQ  = $f6               ; Tune Request              (0 data)
ST_ENDSYSEX = $f7               ; End of Exclusive          (0 data)
ST_CLOCK    = $f8               ; Clock                     (0 data)
ST_START    = $fa               ; Clock Start               (0 data)
ST_CONTINUE = $fb               ; Clock Continue            (0 data)
ST_STOP     = $fc               ; Clock Stop                (0 data)
ST_SENSE    = $fe               ; Active Sensing            (0 data)
ST_RESET    = $ff               ; System Reset              (0 data)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI KERNAL JUMP TABLE                                                  Offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI Out
SETOUT:     jmp _SETOUT         ; Set MIDI port to output mode              0000
SETCH:      jmp _SETCH          ; Set MIDI channel                          0003
MIDIOUT:    jmp _MIDIOUT        ; Send next MIDI byte to stream             0006
NOTEON:     jmp _NOTEON         ; Note on                                   0009
NOTEOFF:    jmp _NOTEOFF        ; Note off                                  000c
POLYPRES:   jmp _POLYPRES       ; Poly pressure                             000f
CONTROLC:   jmp _CONTROLC       ; Control change                            0012
PROGRAMC:   jmp _PROGRAMC       ; Program change                            0015
CHPRES:     jmp _CHPRES         ; Channel pressure                          0018
PITCHB:     jmp _PITCHB         ; Pitch bend                                001b

; MIDI In
MIDIINIT:                       ; Alias for SETIN
SETIN:      jmp _SETIN          ; Set MIDI port to input mode               001e
GETCH:      jmp _GETCH          ; Get MIDI channel for message              0021
SETST:      jmp _SETST          ; Set MIDI status and channel               0024
GETST:      jmp _GETST          ; Get MIDI status                           0027
CHKMIDI:    jmp _CHKMIDI        ; Check MIDI in interrupt                   002a
MIDIIN:     jmp _MIDIIN         ; Get next MIDI byte in stream              002d
MAKEMSG:    jmp _MAKEMSG        ; Add incoming byte to MIDI message         0030
MSGSIZE:    jmp _MSGSIZE        ; Get size of MIDI message                  0033
GETMSG:     jmp _GETMSG         ; Get complete MIDI message                 0036

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI ROUTINE IMPLEMENTATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SETOUT
; Prepare port for MIDI output
; Preparations - None
; Registers Affected - None
_SETOUT:    pha                 ; Save A for command, etc.
            lda #%11111111      ; Set DDR for output on all lines
            sta DDR             ; ,,
            lda #%10000000      ; Set PCR for output handshaking mode
            sta PCR             ; ,,
            lda #%00001000      ; Disable CB2 interrupt
            sta IER             ; ,,
            pla
            rts

; SETIN (alias MIDIINIT)
; Prepare port for MIDI input
; Preparations - None
; Registers Affected - A
_SETIN:     lda #%00000000      ; Set DDR for input on all lines
            sta DDR             ; ,,
            sta PCR             ; Set PCR for interrupt input mode
            lda #%10001000      ; Enable CB2 interrupt
            sta IER             ; ,,
            lda #$ff            ; Initialize message not ready
            sta DATACOUNT       ; ,,
            rts

; SETCH
; Set MIDI channel
; Preparations - SETOUT, A = MIDI channel ($00 - $0f)
; Registers Affected - A
_SETCH:     and #%00001111      ; Constrain to 0-15
            sta MIDIST
            rts
            
; GETCH
; Get MIDI channel
; Registers Affected - A
; Return Values - MIDI Channel in A
_GETCH:     lda MIDIST
            and #%00001111
            rts
            
; SETST
; Set MIDI status
; Preparations - SETIN, MIDIIN, A = MIDI status byte (with channel)
; Registers Affected - None
_SETST:     sta MIDIST
            rts
   
; GETST
; Get MIDI status
; Preparations - SETIN, MIDIIN
; Registers Affeted - A
; Return Values - MIDI Status in A
_GETST:     lda MIDIST          ; Get MIDI status and channel
            and #%11110000      ; Mask away the channel for command dispatch
            cmp #%11110000      ; But if the status is a real-time or system
            bne getst_r         ;   exclusive message, the low nybble is not
            ora MIDIST          ;   a channel, so put it back.
getst_r:    rts
            
; CHKMIDI
; Check for MIDI In Interrupt
; If Z is clear, a new byte is at the input. See MIDIIN.
; Preparations - SETIN
; Registers Affected - A
; Return Values - Z flag (clear = new byte at input)
_CHKMIDI:   lda #%00001000      ; Check bit 3 of IFR, which indicates
            bit IFR             ;   that the interface has written to the port
            rts
            
; MIDIIN
; Receive byte from MIDI port in A
; Preparations - SETIN, CHKMIDI
; Registers Affected - A
; Return Values - Port value in A
_MIDIIN:    lda UPORT
            rts

; NOTEON
; Send Note On command
; Preparations - SETOUT, SETCH, X = note number, Y = velocity
; Registers Affected - A
_NOTEON:    lda #ST_NOTEON      ; Specify Note On status
            .byte $3c           ; Skip word
            
; NOTEOFF
; Send Note Off command
; Preparations - SETOUT, SETCH, X = note number, Y = velocity
; Registers Affected - A   
_NOTEOFF:   lda #ST_NOTEOFF
            .byte $3c           ; Skip word

; POLYPRES
; Send Polyphonic Pressure command
; Preparations - SETOUT, SETCH, X = note number, Y = pressure
; Registers Affected - A            
_POLYPRES:  lda #ST_POLYPR
            .byte $3c           ; Skip word  
            
; PITCHB
; Send Pitch Bend command
; Preparations - SETOUT, SETCH, X = Bend LSB (0-127), Y = Bend MSB (0-127)
; Registers Affected - A
_PITCHB:    lda #ST_PITCHB
            .byte $3c           ; Skip word
            
; CONTROLC
; Send Continuous Control command
; Preparations - SETOUT, SETCH, X = controller number, Y = amount
; Registers Affected - A
_CONTROLC:  lda #ST_CONTROLC
            ; Fall through to MIDICMD
                     
MIDICMD:    ora MIDIST          ; Generic endpoint for a typical
            jsr MIDIOUT         ;   three-byte MIDI command
            txa                 ;   with Data 1 in X, and
            and #%01111111      ;   ,, (constrain to 0-127)
            jsr MIDIOUT         ;   ,,
            tya                 ;   Data 2 in Y
            and #%01111111      ;   ,, (constrain to 0-127)
            ; Fall through to _MIDIOUT
            
; MIDIOUT
; Send byte to MIDI port, wait for acknowledgement
; Preparations - SETOUT, SETCH, A = MIDI byte
; Registers Affected - None
; Return Values - Carry flag (clear if acknowledged, set if timeout)
_MIDIOUT:   pha                 ; Preserve A
            jsr _SETOUT         ; Set output mode
            sta UPORT           ; Write to port
            txa                 ; Preserve X during acknowledgement
            pha                 ;   timeout check
            ldx #0              ; X = Timeout counter
            lda #%00010000      ; Wait for bit 4 of the interrupt flag
-wait:      dex                 ; Check for interface timeout
            beq timeout         ; ,,
            bit IFR             ; Check interrupt flag for acknowledgement
            beq wait            ;   of MIDI message by the interface
            clc
            .byte $34           ; Skip Byte (SKB)
timeout:    sec
;            ldx #0
;-delay      bit $ffff
;            bit $ffff
;            bit $ffff
;            dex
;            bne delay
out_r:      jsr _SETIN          ; Return to input mode
            pla                 ; Get X back
            tax                 ; ,,
            pla                 ; Get A back
            rts

; PROGRAMC
; Send Program Change command
; Preparations - SETOUT, SETCH, X = program number
; Registers Affected - A
_PROGRAMC:  lda #ST_PROGRAMC
            .byte $3c           ; Skip word

; CHPRES
; Send Channel Pressure command
; Preparations - SETOUT, SETCH, X = pressure amount
; Registers Affected - A
_CHPRES:    lda #ST_CHPR
            ; Fall through to MIDICMD2

MIDICMD2:   ora MIDIST          ; Generic endpoint for a two-byte
            jsr _MIDIOUT        ;   MIDI command
            txa                 ;   ,,
            and #%01111111      ;   ,, (constrain to 0-127)
            jmp _MIDIOUT        ;   ,,

; MAKEMSG
; Make MIDI Message
; Accept bytes until the appropriate number of parameters have been added
; Preparations - SETIN, CHKMIDI 
; Registers Affected - A, X        
_MAKEMSG:   jsr _MIDIIN         ; Get the next available MIDI byte
            bmi new_status      ; If it's a new status byte, prepare for data
            ldx DATACOUNT       ; Where are we in the data count?
            bmi msg_err         ; If no status byte is set, nothing to do
            beq msg_err         ; If the message is complete, nothing to do
set_data:   dex                 ; Decrement data byte count; when at 0, message
            stx DATACOUNT       ;   is considered complete.
            sta DATA2,x         ; Write the byte to message storage
msg_err:    rts                 ; ,,
new_status: jsr _SETST          ; Set status byte
set_count:  jsr _MSGSIZE        ; Get message size
            sta DATACOUNT       ; Number of bytes remaining for this message
            rts
            
; MSGSIZE
; Get data size of MIDI message, in data bytes (0, 1, or 2)
; Registers Affected - A, X     
; Return Values - Number of data bytes in A
_MSGSIZE:   ldx #13             ; X is the index of the last status message
-loop:      cmp SizeTableS,x    ; Is this the status we're looking for?
            beq f_st            ; If so, look up the number of data bytes
            dex                 ; Iterate
            bpl loop            ; ,,
            lda #1              ; If the message is not in the table, it is
            rts                 ;   a one-data-byte status
f_st:       lda SizeTableD,x    ; Set number of data at index.
            rts
        
; GETMSG
; Check for complete MIDI message
; Preparations - SETIN, CHKMIDI, MIDICMD
; Return Values -
;   1) Carry flag - set if message is complete
;   2) A contains the status byte
;   3) X contains DATA1
;   4) Y contains DATA2 (if used)
_GETMSG:    clc                 ; Default to carry clear (no message)
            lda DATACOUNT       ; Is a complete message waiting?
            bne no_msg          ; If DATACOUNT != 0 incomplete or unstarted
            jsr _GETST          ; Get status (without channel) for return
            pha                 ; Store status during size calculation
            jsr _MSGSIZE        ; If this message has one data byte, that
            ldx DATA2           ;   byte is in DATA2, so set X appropriately
            cmp #1              ; Otherwise, set X with DATA1 and Y with
            beq set_rst         ;   DATA2
            ldx DATA1           ;   ,,
            ldy DATA2           ;   ,,
set_rst:    pla                 ; Put status back in A            
            dec DATACOUNT       ; Set message from 0 to "unstarted" ($ff)
            sec                 ; Set carry to indicate message is ready
no_msg:     rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATA TABLES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           
; Table to look up number of data bytes for each MIDI command
; Any status byte not listed here is treated as a one-data-byte command
SizeTableS: .byte ST_NOTEON, ST_NOTEOFF, ST_POLYPR, ST_CONTROLC, ST_PITCHB
            .byte ST_MTC, ST_SONGPOS, ST_TUNEREQ, ST_ENDSYSEX, ST_CLOCK
            .byte ST_START, ST_CONTINUE, ST_STOP, ST_SYSEX
SizeTableD: .byte 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0
