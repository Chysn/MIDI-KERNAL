;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                   MIDI KERNAL
;                    MIDI Routines for VIC-20 User Port Projects
;                             (c)2021, Jason Justian
;                  
; Release 1 - September 2, 2021
; Release 2 - September 10, 2021
; Assembled with XA
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2021, Jason Justian
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI OUTPUT DOCUMENTATION
;
; Channel messages have their own MIDI KERNAL routines
; Example
;     jsr SETOUT                ; SETOUT and SETCH don't need to be done for
;     lda #CHANNEL              ;   each command invocation, only when they need
;     jsr SETCH                 ;   to be changed
;     ldx #DATA1                ; Range of DATA1 is 0 - 127
;     ldy #DATA2                ; Range of DATA2 is 0 - 127
;     jsr ROUTINE               ; See the routine table below
;
; System messages are generated byte-by-byte with the MIDIOUT routine
; Example
;     lda #ST_CLOCK
;     jsr MIDIOUT
;     lda #ST_
;
;    ROUTINE    ;     DESCRIPTION       ;     DATA1 (X)     ;     DATA2  (Y)     
;---------------;-----------------------;-------------------;-------------------
; NOTEON        ; Note On               ; Note Number       ; Velocity
; NOTEOFF       ; Note Off              ; Note Number       ; Velocity*
; POLYPRES      ; Polyphonic Pressure   ; Note Number       ; Pressure Amount
; CONTROLC      ; Control Change        ; Controller Number ; Control Amount
; PROGRAMC      ; Program Change        ; Program Number    ; (unused)
; CHPRES        ; Channel Pressure      ; Pressure Amount   ; (unused)
; PITCHB        ; Pitch Bend            ; Amount - LSB      ; Amount - MSB
;
; * Usually optional, check instrument's implementation chart
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                            MIDI INPUT DOCUMENTATION
;
; Example
;     jsr SETIN                 ; In setup routine where MIDI In is expected
;
;     ; Main loop checks for complete MIDI message and acts on it
;     jsr GETMSG                ; Has a complete MIDI message been received?
;     bcc main_loop             ; If not, do whatever else your program does
;     cmp #ST_NOTEON            ; Dispatch each implemented MIDI command to
;     beq handle_note_on        ;   the appropriate code.
;     cmp #ST_NOTEOFF           ;   * X holds DATA1 and Y holds DATA2
;     beq handle_note_off       ;   * Use jsr GETCH to get the message channel
;     ; etc....                 ;   * See "Status Message Constants" below
;
;     ; Interrupt Service Routine ($0318/$0319 NMI vector)
; isr pha                       ; Custom NMI handlers need to store registers
;     txa                       ;   for return.
;     pha                       ;   ,,
;     tya                       ;   ,,
;     pha                       ;   ,,
;     jsr CHKMIDI               ; Is this a MIDI-based interrupt?
;     bne mi                    ;   If so, handle MIDI input
;     jmp $feb2                 ;   If not, RESTORE was (probably) pressed
; mi  jsr MAKEMSG               ; Get waiting MIDI byte and add to message
;     pla                       ; Return from MIDI interrupt (or jmp $ff56)
;     tay                       ; ,,
;     pla                       ; ,,
;     tax                       ; ,,
;     pla                       ; ,,
;     rti                       ; ,,
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LABEL DEFINITIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; VIA Registers
DDR         = $9112             ; Data Direction Register
UPORT       = $9110             ; User Port
PCR         = $911c             ; Peripheral Control Register
IFR         = $911d             ; Interrupt flag register
IER         = $911e             ; Interrupt enable register

; Memory Locations
MIDIST      = $9e               ; Bits 0-3 = Channel, bits 4-7 = Last Status
DATA2       = $9b               ; MIDI data bytes (they're in reverse order
DATA1       = $9c               ;   because DATACOUNT descends)
DATACOUNT   = $9f               ; Data byte countdown, 0 = message waiting

; Status Message Constants
ST_NOTEON   = $90               ; Note On
ST_NOTEOFF  = $80               ; Note Off
ST_POLYPR   = $a0               ; Poly Pressure
ST_CONTROLC = $b0               ; Control Change
ST_PROGRAMC = $c0               ; Program Change
ST_CHPR     = $d0               ; Channel Pressure
ST_PITCHB   = $e0               ; Pitch Bend

; System Message Constants ($f0-$ff)
ST_SYSEX    = $f0               ; Start System Exclusive
ST_MTC      = $f1               ; MIDI Time Code            (1 data)
ST_SONGPOS  = $f2               ; Song Position Pointer     (2 data)
ST_SONGSEL  = $f3               ; Song Select               (1 data)
ST_TUNEREQ  = $f6               ; Tune Request              (0 data)
ST_ENDSYSEX = $f7               ; End of Exclusive          (0 data)
ST_CLOCK    = $f8               ; Clock                     (0 data)
ST_START    = $fa               ; Clock Start               (0 data)
ST_CONTINUE = $fb               ; Clock Continue            (0 data)
ST_STOP     = $fc               ; Clock Stop                (0 data)
ST_SENSE    = $fe               ; Active Sensing            (0 data)
ST_RESET    = $ff               ; System Reset              (0 data)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI KERNAL JUMP TABLE                                                  Offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETOUT:     jmp _SETOUT         ; Set MIDI port to output mode              0000
SETIN:      jmp _SETIN          ; Set MIDI port to input mode               0003
SETCH:      jmp _SETCH          ; Set MIDI channel (out)                    0006
GETCH:      jmp _GETCH          ; Get MIDI channel for message (in)         0009
SETST:      jmp _SETST          ; Set MIDI status and channel (in)          000c
GETST:      jmp _GETST          ; Get MIDI status (in)                      000f
CHKMIDI:    jmp _CHKMIDI        ; Check MIDI in interrupt (in)              0012
MIDIOUT:    jmp _MIDIOUT        ; Send next MIDI byte to stream (out)       0015
MIDIIN:     jmp _MIDIIN         ; Get next MIDI byte in stream (in)         0018
NOTEON:     jmp _NOTEON         ; Note on (out)                             001b
NOTEOFF:    jmp _NOTEOFF        ; Note off (out)                            001e
POLYPRES:   jmp _POLYPRES       ; Poly pressure (out)                       0021
CONTROLC:   jmp _CONTROLC       ; Control change (out)                      0024
PROGRAMC:   jmp _PROGRAMC       ; Program change (out)                      0027
CHPRES:     jmp _CHPRES         ; Channel pressure (out)                    002a
PITCHB:     jmp _PITCHB         ; Pitch bend (out)                          002d
MAKEMSG:    jmp _MAKEMSG        ; Add incoming byte to MIDI message (in)    0030
MSGSIZE:    jmp _MSGSIZE        ; Get size of MIDI message (in)             0033
GETMSG:     jmp _GETMSG         ; Get complete MIDI message (in)            0036

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MIDI ROUTINE IMPLEMENTATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SETOUT
; Prepare port for MIDI output
; Preparations - None
; Registers Affected - A
_SETOUT:    lda #%11111111      ; Set DDR for input on all lines
            sta DDR             ; ,,
            lda #%10000000      ; Set PCR for output handshaking mode
            sta PCR             ; ,,
            lda #%00001000      ; Disable CB2 interrupt
            sta IER             ; ,,
            rts

; SETIN
; Prepare port for MIDI input
; Preparations - None
; Registers Affected - A
_SETIN:     lda #%00000000      ; Set DDR for output on all lines
            sta DDR             ; ,,
            sta PCR             ; Set PCR for interrupt input mode
            lda #%10001000      ; Enable CB2 interrupt
            sta IER             ; ,,
            lda #$ff            ; Initialize message not ready
            sta DATACOUNT       ; ,,
            rts

; SETCH
; Set MIDI channel
; Preparations - SETOUT, A = MIDI channel ($00 - $0f)
; Registers Affected - A
_SETCH:     and #%00001111      ; Constrain to 0-15
            sta MIDIST
            rts
            
; GETCH
; Get MIDI channel
; Registers Affected - A
; Return Values - MIDI Channel in A
_GETCH:     lda MIDIST
            and #%00001111
            rts
            
; SETST
; Set MIDI status
; Preparations - SETIN, MIDIIN, A = MIDI status byte (with channel)
; Registers Affected - None
_SETST:     sta MIDIST
            rts
   
; GETST
; Get MIDI status
; Preparations - SETIN, MIDIIN
; Registers Affeted - A
; Return Values - MIDI Status in A
_GETST:     lda MIDIST          ; Get MIDI status and channel
            and #%11110000      ; Mask away the channel for command dispatch
            cmp #%11110000      ; But if the status is a real-time or system
            bne getst_r         ;   exclusive message, the low nybble is not
            ora MIDIST          ;   a channel, so put it back.
getst_r:    rts
            
; CHKMIDI
; Check for MIDI In Interrupt
; If Z is clear, a new byte is at the input. See MIDIIN.
; Preparations - SETIN
; Registers Affected - A
; Return Values - Z flag (clear = new byte at input)
_CHKMIDI:   lda #%00001000      ; Check bit 3 of IFR, which indicates
            bit IFR             ;   that the interface has written to the port
            rts
            
; MIDIOUT
; Send byte to MIDI port, wait for acknowledgement
; Preparations - SETOUT, SETCH, A = MIDI byte
; Registers Affected - A
; Return Values - Carry flag (clear if acknowledged, set if timeout)
_MIDIOUT:   sta UPORT           ; Write to port
            txa                 ; Preserve X during acknowledgement
            pha                 ;   timeout check
            ldx #0              ; X = Timeout counter
            lda #%00010000      ; Wait for bit 4 of the interrupt flag
-wait:      dex                 ; Check for interface timeout
            beq timeout         ; ,,
            bit IFR             ; Check interrupt flag for acknowledgement
            beq wait            ;   of MIDI message by the interface
            pla                 ; Get X back
            tax                 ; ,,
            clc                 ; Clear carry if send OK
            rts
timeout:    pla                 ; Get X back
            tax                 ; ,,
            sec                 ; Set carry if timeout
            rts

; MIDIIN
; Receive byte from MIDI port in A
; Preparations - SETIN, CHKMIDI
; Registers Affected - A
; Return Values - Port value in A
_MIDIIN:    lda UPORT
            rts

; NOTEON
; Send Note On command
; Preparations - SETOUT, SETCH, X = note number, Y = velocity
; Registers Affected - A
_NOTEON:    lda #ST_NOTEON      ; Specify Note On status
MIDICMD:    ora MIDIST          ; Generic endpoint for a typical
            jsr MIDIOUT         ;   three-byte MIDI command
            txa                 ;   with Data 1 in X, and
            and #%01111111      ;   ,, (constrain to 0-127)
            jsr MIDIOUT         ;   ,,
            tya                 ;   Data 2 in Y
            and #%01111111      ;   ,, (constrain to 0-127)
            jmp MIDIOUT         ;   ,,

; NOTEOFF
; Send Note Off command
; Preparations - SETOUT, SETCH, X = note number, Y = velocity
; Registers Affected - A   
_NOTEOFF:   lda #ST_NOTEOFF
            jmp MIDICMD

; POLYPRES
; Send Polyphonic Pressure command
; Preparations - SETOUT, SETCH, X = note number, Y = pressure
; Registers Affected - A            
_POLYPRES:  lda #ST_POLYPR
            jmp MIDICMD

; CONTROLC
; Send Continuous Control command
; Preparations - SETOUT, SETCH, X = controller number, Y = amount
; Registers Affected - A
_CONTROLC:  lda #ST_CONTROLC
            jmp MIDICMD

; PROGRAMC
; Send Program Change command
; Preparations - SETOUT, SETCH, X = program number
; Registers Affected - A
_PROGRAMC:  lda #ST_PROGRAMC
MIDICMD2:   ora MIDIST          ; Generic endpoint for a two-byte
            jsr MIDIOUT         ;   MIDI command
            txa                 ;   ,,
            and #%01111111      ;   ,, (constrain to 0-127)
            jmp MIDIOUT         ;   ,,

; CHPRES
; Send Channel Pressure command
; Preparations - SETOUT, SETCH, X = pressure amount
; Registers Affected - A
_CHPRES:    lda #ST_CHPR
            jmp MIDICMD2 

; PITCHB
; Send Pitch Bend command
; Preparations - SETOUT, SETCH, X = Bend LSB (0-127), Y = Bend MSB (0-127)
; Registers Affected - A
_PITCHB:    lda #ST_PITCHB
            jmp MIDICMD

; MAKEMSG
; Make MIDI Message
; Accept bytes until the appropriate number of parameters have been added
; Preparations - SETIN, CHKMIDI 
; Registers Affected - A, X        
_MAKEMSG:   jsr MIDIIN          ; Get the next available MIDI byte
            bmi new_status      ; If it's a new status byte, prepare for data
            bit DATACOUNT       ; If DATACOUNT is negative, a status byte was
            bpl set_data        ;   expected, so handle running status
running_st: pha                 ; Running status; re-use the last status
            jsr set_count       ;   byte, reset the byte count, and then add
            pla                 ;   the data to message storage
set_data:   dec DATACOUNT       ; Which data byte is this?
            ldx DATACOUNT       ; ,,
            cpx #2              ; ,, If a data byte follows a zero-byte status,
            bcs msg_error       ; ,, ignore it
            sta DATA2,x         ; Write the byte to message storage
msg_error:  rts                 ; ,,
new_status: jsr SETST           ; Set status byte
set_count:  jsr MSGSIZE         ; Get message size
            sta DATACOUNT       ; Number of bytes remaining for this message
            rts
            
; MSGSIZE
; Get data size of MIDI message, in data bytes
; Registers Affected - A, X     
; Return Values - Number of data bytes in A
_MSGSIZE:   ldx #12             ; X is the index of the last status message
-loop:      cmp SizeTableS,x    ; Is this the status we're looking for?
            beq f_st            ; If so, look up the number of data bytes
            dex                 ; Iterate
            bpl loop            ; ,,
            lda #1              ; If the message is not in the table, it is
            rts                 ;   a one-data-byte status
f_st:       lda SizeTableD,x    ; Set number of data at index.
            rts
        
; GETMSG
; Check for complete MIDI message
; Preparations - SETIN, CHKMIDI, MIDICMD
; Return Values -
;   1) Carry flag - set if message is complete
;   2) A contains the status byte
;   3) X contains DATA1
;   4) Y contains DATA2 (if used)
_GETMSG:    clc                 ; Default to carry clear (no message)
            lda DATACOUNT       ; Is a complete message waiting?
            bne no_msg          ; If DATACOUNT != 0, message is incomplete
            ldx DATA1           ; Populate data bytes
            ldy DATA2           ; ,,
            jsr GETST           ; Get status (without channel) for return
            dec DATACOUNT       ; Set message to unready, to avoid duplicate
            sec                 ; Set carry to indicate message is ready
no_msg:     rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DATA TABLES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;           
; Table to look up number of data bytes for each MIDI command
; Any status byte not listed here is treated as a one-data-byte command
SizeTableS: .byte ST_NOTEON, ST_NOTEOFF, ST_POLYPR, ST_CONTROLC, ST_PITCHB
            .byte ST_MTC, ST_SONGPOS, ST_TUNEREQ, ST_ENDSYSEX, ST_CLOCK
            .byte ST_START, ST_CONTINUE, ST_STOP
SizeTableD: .byte 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0
